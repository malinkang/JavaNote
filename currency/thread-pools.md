# 线程池

<!--more-->


## 设置线程池的大小

你可能经常在面试中被问到这两个问题，如果想要很好地回答它们首先你需要了解，我们调整线程池中的线程数量的最主要的 目的是为了充分并合理地使用 CPU 和内存等资源，从而最大限度地提高程序的性能。在实际工作中，我们需要根据任务类型 的不同选择对应的策略。
CPU 密集型任务
首先，我们来看 CPU 密集型任务，比如加密、解密、压缩、计算等一系列需要大量耗费 CPU 资源的任务。对于这样的任务最 佳的线程数为 CPU 核心数的 1~2 倍，如果设置过多的线程数，实际上并不会起到很好的效果。此时假设我们设置的线程数量 是 CPU 核心数的 2 倍以上，因为计算任务非常重，会占用大量的 CPU 资源，所以这时 CPU 的每个核心工作基本都是满负荷 的，而我们又设置了过多的线程，每个线程都想去利用 CPU 资源来执行自己的任务，这就会造成不必要的上下文切换，此时 线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。
针对这种情况，我们最好还要同时考虑在同一台机器上还有哪些其他会占用过多 CPU 资源的程序在运行，然后对资源使用做 整体的平衡。
耗时 IO 型任务
第二种任务是耗时 IO 型，比如数据库、文件的读写，网络通信等任务，这种任务的特点是并不会特别消耗 CPU 资源，但是 IO 操作很耗时，总体会占用比较多的时间。对于这种任务最大线程数一般会大于 CPU 核心数很多倍，因为 IO 读写速度相比 于 CPU 的速度而言是比较慢的，如果我们设置过少的线程数，就可能导致 CPU 资源的浪费。而如果我们设置更多的线程数， 那么当一部分线程正在等待 IO 的时候，它们此时并不需要 CPU 来计算，那么另外的线程便可以利用 CPU 去执行其他的任 务，互不影响，这样的话在任务队列中等待的任务就会减少，可以更好地利用资源。
《Java并发编程实战》的作者 Brain Goetz 推荐的计算方法: 线程数 = CPU 核心数 *(1+平均等待时间/平均工作时间)
通过这个公式，我们可以计算出一个合理的线程数量，如果任务的平均等待时间长，线程数就随之增加，而如果平均工作时间 长，也就是对于我们上面的 CPU 密集型任务，线程数就随之减少。
太少的线程数会使得程序整体性能降低，而过多的线程也会消耗内存等其他资源，所以如果想要更准确的话，可以进行压测， 监控 JVM 的线程情况以及 CPU 的负载情况，根据实际情况衡量应该创建的线程数，合理并充分利用资源。

结论
综上所述我们就可以得出一个结论: 线程的平均工作时间所占比例越高，就需要越少的线程; 线程的平均等待时间所占比例越高，就需要越多的线程; 针对不同的程序，进行对应的实际测试就可以得到最合适的选择。

## 8.3 配置ThreadPoolExecutor

### 8.3.1 线程的创建于销毁

### 队列任务

`ThreadPoolExecutor`允许提供一个`BlockingQueue`来保存等待执行的任务。基本的任务排队方法有4种：

* 无界队列
* 有界队列
* 同步移交（Synchronous Handoff）。
* DelayedWorkQueue

队列的选择与其他的配置参数有关，例如线程池的大小等。

`newFixedThreadPool`和`newSingleThreadExecutor`在默认情况下使用一个无界队列`LinkedBlockingQueue`。如果所有工作线程都处于忙碌状态，那么任务将在队列中等候。如果任务持续快速地到达，并且超过了线程池处理它们的速度，那么队列将无限制地增加。

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
//所谓无解就是容量被设置为最大值
public LinkedBlockingQueue() {
    this(Integer.MAX_VALUE); //默认容量为integer的最大值
}
```



一种更稳妥的资源管理策略是使用有界队列，例如`ArrayBlockingQueue`、有界的`LinkedBlockingQueue`、`PriorityBlockingQueue`。有界队列有助于避免资源耗尽的情况发生，但它又带来了新的问题：当队列填满后，新的任务该怎么办？在使用有界的工作队列时，队列的大小与线程池的大小必须一起调节。如果线程池较小而队列较大，那么有助于减少内存使用量，降低CPU的使用率，同时还可以减少上下文切换，但付出的代价是可能会限制吞吐量。

对于非常大的或者无界的线程池，可以通过使用`SynchronousQueue`来避免任务排队，以及直接将任务从生产者移交给工作线程。`SynchronousQueue`不是一个真正的队列，而是一种在线程之间进行移交的机制。要将一个元素放入`SynchronousQueue`中，必须有另一个线程正在等待接受这个元素。如果没有线程正在等待，并且线程池的当前大小小于最大值，那么`ThreadPoolExecutor`将创建一个新的线程，否则根据饱和策略，这个任务将被拒绝。使用直接移交将更高效，因为任务会直接移交给执行它的线程，而不是被首先放在队列中，然后由工作线程从队列中提取该任务。只有当线程池是无界的或者可以拒绝任务时，`SynchronousQueue`才有实际价值。在`newCachedThreadPool`工厂方法中就使用了`SynchronousQueue`。

当使用像`LinkedBlockingQueue`或`ArrayBlockingQueue`这样的FIFO队列时，任务的执行顺序与它们的到达顺序相同。如果想进一步控制任务执行顺序，还可以使用`PriorityBlockingQueue`，这个队列将根据优先级来安排任务。任务的优先级是通过自然顺序或`Comparator`来定义的。

第四种阻塞队列是DelayedWorkQueue，它对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种 线程池的最大特点就是可以延迟执行任务，比如说一定时间后执行任务或是每隔一定的时间执行一次任 务。DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采 用的是“堆”的数据结构。之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，是因 为它们本身正是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行。

### 饱和策略


程池会在以下两种情况下会拒绝新提交的任务。

* 第一种情况是当我们调用 shutdown 等方法关闭线程池后，即便此时可能线程池内部依然有没执行完的任务正在执行，但是由于线程池已经关闭，此时如果再向线程池 内提交任务，就会遭到拒绝。
* 第二种情况是线程池没有能力继续处理新提交的任务，也就是工作已经非常饱和的时候。


工作饱和导致的拒绝举例：比如新建一个线程池，使用容量上限为 10 的 ArrayBlockingQueue 作为任务队列，并且指定线程池的核心线 程数为 5，最大线程数为 10，假设此时有 20 个耗时任务被提交，在这种情况下，线程池会首先创建核心数量的线程，也就是5个线程来执行任务，然后往队列里去放任务， 队列的 10 个容量被放满了之后，会继续创建新线程，直到达到最大线程数 10。此时线程池中一共有 20 个任务，其中 10 个任务正在被 10 个线程执行，还有 10 个任务在任 务队列中等待，而且由于线程池的最大线程数量就是 10，所以已经不能再增加更多的线程来帮忙处理任务了，这就意味着此时线程池工作饱和，这个时候再提交新任务时 就会被拒绝。

JDK提供了几种不同的 RejectedExecutionHandler实现，每种实现都 包含有不同的饱和策略：AbortPolicy、CallerRunsPolicy、DiscardPolicy 和DiscardOldestPolicy。

* AbortPolicy：“中止（Abort）”策略是默认的饱和策略，该策略将抛出未检查的RejectedExecution-Exception。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。

* DiscardPolicy：当新提交的任务无保存到队列中等待执行时，“抛弃（Discard）”策略会悄悄抛弃该任务。

* DiscardOldestPolicy：“抛弃最旧的（Discard-Oldest）”策略则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”饱和策略和优先级队列放在一起使用。）

* CallerRunsPolicy：“调用者运行（Caller-Runs）”策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了execute的线程中执行该任务。



## 参考

* [Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)
