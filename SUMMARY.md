# Table of contents

* [Introduction](README.md)
* [面试题整理](interview.md)

## 《Java编程思想》

* [第2章一切都是对象](thinking-in-java/everything-is-an-object.md)
* [第3章操作符](thinking-in-java/operators.md)
* [第4章控制流程](thinking-in-java/controlling-execution.md)
* [第5章初始化与清理](thinking-in-java/initialization-and-cleanup.md)
* [第6章访问权限控制](thinking-in-java/access-control.md)
* [第7章复用类](thinking-in-java/reusing-classes.md)
* [第8章多态](thinking-in-java/polymorphism.md)
* [第9章接口](thinking-in-java/interfaces.md)
* [第10章内部类](thinking-in-java/inner-classes.md)
* [第11章持有对象](thinking-in-java/holding-your-objects.md)
* [第12章通过异常处理错误](thinking-in-java/error-handling-with-exceptions.md)
* [第13章字符串](thinking-in-java/strings.md)
* [第14章类型信息](thinking-in-java/type-information.md)
* [第15章泛型](thinking-in-java/generics.md)
* [第16章数组](thinking-in-java/arrays.md)
* [第17章容器深入研究](thinking-in-java/containers-in-depth.md)
* [第18章I/O系统](thinking-in-java/i-o.md)
* [第19章枚举类型](thinking-in-java/enumerated-types.md)
* [第20章注解](thinking-in-java/annotations.md)
* [第21章并发](thinking-in-java/concurrency.md)

## 《Effective Java》

* [第2章创建和销毁对象](effective-java/creating-and-destroying-objects.md)
* [第3章对于所有对象都通用的方法](effective-java/methods-common-to-all-objects.md)
* [第4章类和接口](effective-java/classes-and-interfaces.md)
* [第5章泛型](effective-java/generics.md)
* [第6章枚举和注解](effective-java/enums-and-annotations.md)
* [第7章lambda表达式和流](effective-java/lambdas-and-streams.md)
* [第8章方法](effective-java/methods.md)
* [第9章通用程序设计](effective-java/general-programming.md)
* [第10章异常](effective-java/exceptions.md)
* [第11章并发](effective-java/concurrency.md)
* [第12章序列化](effective-java/serialization.md)

## jvm 

* [Java内存区域与内存溢出](jvm/runtime-data-areas.md)
* [垃圾收集器与内存分配策略](jvm/garbage-collection.md)
* [类文件结构](jvm/class-file-structure.md)
* [虚拟机类加载机制](jvm/classloader.md)
* [虚拟机字节码执行引擎](jvm/execution-engin.md)
* [编译期优化](jvm/compilation-optimization.md)
* [Java内存模型与线程](jvm/java-memory-model-and-thread.md)
* [线程安全与锁优化](jvm/thread-safe-and-lock-optimization.md)

## 并发

* [原子变量与非阻塞同步机制](currency/atomic-variables-and-nonblocking-synchronization.md)
* [基础构建模块](currency/building-blocks.md)
* [构建自定义的同步工具](currency/building-custom-synchronizers.md)
* [取消与关闭](currency/cancellation-and-shutdown.md)
* [显式锁](currency/explicit-locks.md)
* [对象的共享](currency/sharing-objects.md)
* [任务执行](currency/task-execution.md)
* [Java内存模型](currency/the-java-momory-model.md)
* [线程池](currency/thread-pools.md)
* [线程安全](currency/synchronized.md)
* [CAS](currency/compare-and-swap.md)
* [原子变量](currency/atomic-variables.md)
* [final](currency/final.md)
* [threadlocal](currency/threadlocal.md)
* [aqs](currency/aqs.md)
* [callable](currency/callable.md)
* [future](currency/future.md)

## 并发编程78讲


* [开篇](78/开篇/)
 * [开篇词由点及面，搭建你的Java并发知识网](78/开篇/开篇词由点及面，搭建你的Java并发知识网.md)
* [线程基础升华](78/开篇/)
 * [第01讲为何说只有1种实现线程的方法](78/线程基础升华/第01讲为何说只有1种实现线程的方法.md)
 * [第04讲waitnotifynotifyAll方法的使用注意事项](78/线程基础升华/第04讲waitnotifynotifyAll方法的使用注意事项.md)
 * [第02讲如何正确停止线程为什么volatile标记位的停止方法是错误的](78/线程基础升华/第02讲如何正确停止线程为什么volatile标记位的停止方法是错误的.md)
 * [第03讲线程是如何在6种状态之间转换的](78/线程基础升华/第03讲线程是如何在6种状态之间转换的.md)
 * [第05讲有哪几种实现生产者消费者模式的方法](78/线程基础升华/第05讲有哪几种实现生产者消费者模式的方法.md)
* [究竟什么是线程安全？](78/究竟什么是线程安全？/)
 * [第06讲一共有哪3类线程安全问题](78/究竟什么是线程安全？/第06讲一共有哪3类线程安全问题.md)
 * [第08讲为什么多线程会带来性能问题](78/究竟什么是线程安全？/第08讲为什么多线程会带来性能问题.md)
* [线程池](78/线程池/)
 * [第18讲线程池实现“线程复用”的原理](78/线程池/第18讲线程池实现“线程复用”的原理.md)
 * [第17讲如何正确关闭线程池shutdown和shutdownNow的区别](78/线程池/第17讲如何正确关闭线程池shutdown和shutdownNow的区别.md)
 * [第14讲为什么不应该自动创建线程池](78/线程池/第14讲为什么不应该自动创建线程池.md)
 * [第10讲线程池的各个参数的含义](78/线程池/第10讲线程池的各个参数的含义.md)
 * [第12讲有哪6种常见的线程池什么是Java8的ForkJoinPool](78/线程池/第12讲有哪6种常见的线程池什么是Java8的ForkJoinPool.md)
 * [第09讲使用线程池比手动创建线程好在哪里](78/线程池/第09讲使用线程池比手动创建线程好在哪里.md)
 * [第11讲线程池有哪4种拒绝策略](78/线程池/第11讲线程池有哪4种拒绝策略.md)
 * [第15讲合适的线程数量是多少CPU核心数和线程数的关系](78/线程池/第15讲合适的线程数量是多少CPU核心数和线程数的关系.md)
 * [第13讲线程池常用的阻塞队列有哪些](78/线程池/第13讲线程池常用的阻塞队列有哪些.md)
 * [第16讲如何根据实际需要，定制自己的线程池](78/线程池/第16讲如何根据实际需要，定制自己的线程池.md)
* [各种各样的“锁”](78/各种各样的“锁”/)
 * [第22讲synchronized和Lock孰优孰劣，如何选择](78/各种各样的“锁”/第22讲synchronized和Lock孰优孰劣，如何选择.md)
 * [第28讲JVM对锁进行了哪些优化](78/各种各样的“锁”/第28讲JVM对锁进行了哪些优化.md)
 * [第21讲如何看到synchronized背后的“monitor锁”](78/各种各样的“锁”/第21讲如何看到synchronized背后的“monitor锁”.md)
 * [第25讲读写锁ReadWriteLock获取锁有哪些规则](78/各种各样的“锁”/第25讲读写锁ReadWriteLock获取锁有哪些规则.md)
 * [第27讲什么是自旋锁自旋的好处和后果是什么呢](78/各种各样的“锁”/第27讲什么是自旋锁自旋的好处和后果是什么呢.md)
 * [第19讲你知道哪几种锁分别有什么特点](78/各种各样的“锁”/第19讲你知道哪几种锁分别有什么特点.md)
 * [第24讲讲一讲公平锁和非公平锁，为什么要“非公平”](78/各种各样的“锁”/第24讲讲一讲公平锁和非公平锁，为什么要“非公平”.md)
 * [第26讲读锁应该插队吗什么是读写锁的升降级](78/各种各样的“锁”/第26讲读锁应该插队吗什么是读写锁的升降级.md)
 * [第23讲Lock有哪几个常用方法分别有什么用](78/各种各样的“锁”/第23讲Lock有哪几个常用方法分别有什么用.md)
* [并发容器面面观](78/并发容器面面观/)
 * [第29讲HashMap为什么是线程不安全的](78/并发容器面面观/第29讲HashMap为什么是线程不安全的.md)
 * [第32讲同样是线程安全，ConcurrentHashMap和Hashtable的区别](78/并发容器面面观/第32讲同样是线程安全，ConcurrentHashMap和Hashtable的区别.md)
 * [第31讲为什么Map桶中超过8个才转为红黑树](78/并发容器面面观/第31讲为什么Map桶中超过8个才转为红黑树.md)
 * [第33讲CopyOnWriteArrayList有什么特点](78/并发容器面面观/第33讲CopyOnWriteArrayList有什么特点.md)
 * [第30讲ConcurrentHashMap在Java7和8有何不同](78/并发容器面面观/第30讲ConcurrentHashMap在Java7和8有何不同.md)
* [阻塞队列](78/阻塞队列/)
 * [第36讲有哪几种常见的阻塞队列](78/阻塞队列/第36讲有哪几种常见的阻塞队列.md)
 * [第34讲什么是阻塞队列](78/阻塞队列/第34讲什么是阻塞队列.md)
 * [第38讲如何选择适合自己的阻塞队列](78/阻塞队列/第38讲如何选择适合自己的阻塞队列.md)
 * [第35讲阻塞队列包含哪些常用的方法add、offer、put等方法的区别](78/阻塞队列/第35讲阻塞队列包含哪些常用的方法add、offer、put等方法的区别.md)
 * [第37讲阻塞和非阻塞队列的并发安全原理是什么](78/阻塞队列/第37讲阻塞和非阻塞队列的并发安全原理是什么.md)
* [原子类](78/原子类/)
 * [第42讲AtomicInteger和synchronized的异同点](78/原子类/第42讲AtomicInteger和synchronized的异同点.md)
 * [第41讲原子类和volatile有什么异同](78/原子类/第41讲原子类和volatile有什么异同.md)
 * [第43讲Java8中Adder和Accumulator有什么区别](78/原子类/第43讲Java8中Adder和Accumulator有什么区别.md)
 * [第40讲AtomicInteger在高并发下性能不好，如何解决为什么](78/原子类/第40讲AtomicInteger在高并发下性能不好，如何解决为什么.md)
 * [第39讲原子类是如何利用CAS保证线程安全的](78/原子类/第39讲原子类是如何利用CAS保证线程安全的.md)
* [ThreadLocal](78/ThreadLocal/)
 * [第44讲ThreadLocal适合用在哪些实际生产的场景中](78/ThreadLocal/第44讲ThreadLocal适合用在哪些实际生产的场景中.md)
 * [第45讲ThreadLocal是用来解决共享资源的多线程访问的问题吗](78/ThreadLocal/第45讲ThreadLocal是用来解决共享资源的多线程访问的问题吗.md)
 * [第46讲多个ThreadLocal在Thread中的threadlocals里是怎么存储的](78/ThreadLocal/第46讲多个ThreadLocal在Thread中的threadlocals里是怎么存储的.md)
 * [第47讲内存泄漏——为何每次用完ThreadLocal都要调用remove()](78/ThreadLocal/第47讲内存泄漏——为何每次用完ThreadLocal都要调用remove().md)
* [Future掌控未来](78/Future掌控未来/)
 * [第48讲Callable和Runnable的不同](78/Future掌控未来/第48讲Callable和Runnable的不同.md)
 * [第49讲Future的主要功能是什么](78/Future掌控未来/第49讲Future的主要功能是什么.md)
 * [第50讲使用Future有哪些注意点Future产生新的线程了吗](78/Future掌控未来/第50讲使用Future有哪些注意点Future产生新的线程了吗.md)
 * [第51讲如何利用CompletableFuture实现“旅游平台”问题](78/Future掌控未来/第51讲如何利用CompletableFuture实现“旅游平台”问题.md)
* [线程协作](78/线程协作/)
 * [第52讲信号量能被FixedThreadPool替代吗](78/线程协作/第52讲信号量能被FixedThreadPool替代吗.md)
 * [第55讲Condition、object.wait()和notify()的关系](78/线程协作/第55讲Condition、object.wait()和notify()的关系.md)
 * [第54讲CyclicBarrier和CountdownLatch有什么异同](78/线程协作/第54讲CyclicBarrier和CountdownLatch有什么异同.md)
 * [第53讲CountDownLatch是如何安排线程执行顺序的](78/线程协作/第53讲CountDownLatch是如何安排线程执行顺序的.md)
* [Java内存模型](78/Java内存模型/)
 * [第63讲单例模式的双重检查锁模式为什么必须加volatile](78/Java内存模型/第63讲单例模式的双重检查锁模式为什么必须加volatile.md)
 * [第59讲什么是“内存可见性”问题](78/Java内存模型/第59讲什么是“内存可见性”问题.md)
 * [第56讲讲一讲什么是Java内存模型](78/Java内存模型/第56讲讲一讲什么是Java内存模型.md)
 * [第57讲什么是指令重排序为什么要重排序](78/Java内存模型/第57讲什么是指令重排序为什么要重排序.md)
 * [第58讲Java中的原子操作有哪些注意事项](78/Java内存模型/第58讲Java中的原子操作有哪些注意事项.md)
 * [第61讲什么是happensbefore规则](78/Java内存模型/第61讲什么是happensbefore规则.md)
 * [第60讲主内存和工作内存的关系](78/Java内存模型/第60讲主内存和工作内存的关系.md)
 * [第62讲volatile的作用是什么与synchronized有什么异同](78/Java内存模型/第62讲volatile的作用是什么与synchronized有什么异同.md)
* [CAS原理](78/CAS原理/)
 * [第65讲CAS和乐观锁的关系，什么时候会用到CAS](78/CAS原理/第65讲CAS和乐观锁的关系，什么时候会用到CAS.md)
 * [第64讲你知道什么是CAS吗](78/CAS原理/第64讲你知道什么是CAS吗.md)
 * [第66讲CAS有什么缺点](78/CAS原理/第66讲CAS有什么缺点.md)
* [死锁问题](78/死锁问题/)
 * [第71讲讲一讲经典的哲学家就餐问题](78/死锁问题/第71讲讲一讲经典的哲学家就餐问题.md)
 * [第70讲有哪些解决死锁问题的策略](78/死锁问题/第70讲有哪些解决死锁问题的策略.md)
 * [第68讲发生死锁必须满足哪4个条件](78/死锁问题/第68讲发生死锁必须满足哪4个条件.md)
 * [第69讲如何用命令行和代码定位死锁](78/死锁问题/第69讲如何用命令行和代码定位死锁.md)
 * [第67讲如何写一个必然死锁的例子](78/死锁问题/第67讲如何写一个必然死锁的例子.md)
* [final关键字和“不变性”](78/开篇/)
 * [第73讲为什么加了final却依然无法拥有“不变性”](78/final关键字和“不变性”/第73讲为什么加了final却依然无法拥有“不变性”.md)
 * [第74讲为什么String被设计为是不可变的](78/final关键字和“不变性”/第74讲为什么String被设计为是不可变的.md)
 * [第72讲final的三种用法是什么](78/final关键字和“不变性”/第72讲final的三种用法是什么.md)
* [AQS框架](78/AQS框架/)
 * [第75讲为什么需要AQSAQS的作用和重要性是什么](78/AQS框架/第75讲为什么需要AQSAQS的作用和重要性是什么.md)
 * [第77讲AQS在CountDownLatch等类中的应用原理是什么](78/AQS框架/第77讲AQS在CountDownLatch等类中的应用原理是什么.md)
 * [第76讲AQS的内部原理是什么样的](78/AQS框架/第76讲AQS的内部原理是什么样的.md)
* [总结](78/总结/)
 * [第78讲一份独家的Java并发工具图谱](78/总结/第78讲一份独家的Java并发工具图谱.md)
 * [参考文献、版权声明、致谢](78/总结/参考文献、版权声明、致谢.md)